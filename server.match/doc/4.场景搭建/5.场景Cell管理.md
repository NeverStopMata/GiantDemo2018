### 场景中的通信数据

服务器网络带宽方面占比最重的一块就是`场景中的通信数据`

可以设想下面的情景：
  - 玩家进入场景后，需要看见其他玩家，那么在完全没有优化过的情况下，只能是全地图玩家数据广播给该玩家。
  - 所有的玩家都在移动，那么服务器需要对每个玩家发送其他玩家数据。流量复杂度为 N&times;(N-1)，即O(n<sup>2</sup>)

因此需要一些算法来减少场景中数据的发送量。


### 游戏中的玩家视野（AOI系统）

通过模仿现实人类视野的概念，可以有效的减少要发送的数据。

这样的系统，通常被称为AOI（area of interest）。

AOI系统的引入，主要为了解决下面的几个问题：
  - **减少场景数据发送量**
  - **减少玩家与其他游戏对象互动时需要消耗的CPU占用率**

在代码实现中，有些著名的AOI算法：

算法      | 应用 | 说明
---------|--------------------------|-------------------------
十字链法  | 开源项目KBEngine             | 场景组织方式不基于格子的。
灯塔     | 征途系列、球球系列、光荣使命         | 通过灯塔维护场景中的游戏对象，每个玩家自己维护视野相关信息

灯塔算法有很多变种：

应用    | 说明
--------|------------------------------------
征途系列 | 九宫格算法。细节关注9屏。
光荣使命 | 没有9屏概念。维护观察者列表与被观察列表
球球系   | 没有9屏概念。不同项目迭代，均有些自己的变化（因为看不到原版，不好下定论）
本项目   | 没有9屏概念。通过前后2帧视野快照，获得场景变化信息


下面将针对本项目的灯塔算法变种做下介绍


### Cell具象化、视野具象化

![图1](https://gitee.com/GaDevGo/mope/raw/master/server/doc/4.%E5%9C%BA%E6%99%AF%E6%90%AD%E5%BB%BA/assert/a.jpg)


上图中，每个黑格子，就是一个Cell。

### 实现细节

在灯塔算法中，将场景划分为1个个Cell（正确的名称叫Tower更为合适）

并按照分而治之的原则，通过Cell为单位维护玩家信息。

同时，玩家身上维护当前帧可以看到的游戏对象列表快照A。

那么每一帧（即下一帧），玩家重新获取当前最新能看到的游戏对象列表B。对比A与B的变化，玩家即可知道场景中的所有变化情况。

详细的：
  - **玩家进入场景**，则根据视野大小获取玩家所有灯塔，将灯塔维护的数据发给玩家

  - **每帧**，根据视野大小获取玩家所有灯塔维护的数据，并与上次数据快照做比较。从而获得所有场景变化信息

  - **玩家与视野内游戏对象互动**，根据视野大小获取玩家所有灯塔维护的数据。再遍历这些数据
